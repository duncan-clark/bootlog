order
order = "diameter"
order = data$marks[order]
order
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
order = data$marks[order]
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
order = data$marks[order]
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
order
data$markfs
data$marks
order
order = "diameter"
order = data$marks[order]
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
formula
order = 'diameter'
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
order = data$marks[order]
order
formula
formula_rhs
formula_rhs = "edges + triangles + star(c(2,3))"
#get network edge from the points available
#for each point find neighbours
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
order = data$marks[order]
order
order = "diameter"
#get network edge from the points available
#for each point find neighbours
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
formula
diameter()
diameter
order = data$marks[order]
order
assign(order,data$marks[order])
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order])
diameter
order
order = "diameter"
order
formula_rhs
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order])
diameter
formula_rhs
formula
lolog = lolog(formula)
diameter
is.numeric(diameter)
type(diameter)
class(diameter)
data$marks[order][,1]
order
assign(order,data$marks[order][,1])
diameter
lolog = lolog(formula)
formula_rhs = "edges + triangles"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
summary(lolog)
plot(net)
formula_rhs = "edges + triangles + star(c(2,3))"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
lolog
summary(lolog)
formula_rhs
formula_rhs ="edges + triangles + star(c(2,3))"
formula_rhs
formula_rhs ="edges + triangles + star(2)"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
formula_rhs ="edges + triangles + star(2) + nodeCov("height")"
formula_rhs ="edges + triangles + star(2) + nodeCov('height'')"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
formula_rhs ="edges + triangles + star(2) + nodeCov('height')"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
formula_rhs
formula_rhs ="edges + triangles + nodeCov('height')"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
lolog
summary(lolog)
plot(net)
plot(net,cex = get.vertex.attribute(net,"height"))
get.vertex.attribute(net,"height")
help(plot.network)
plot(net,vertex.cex = get.vertex.attribute(net,"height"))
plot(net,vertex.cex = get.vertex.attribute(net,"height")/10)
plot(net,vertex.cex = get.vertex.attribute(net,"height")/2)
plot(finpines$x,finpines$y)
rm(list=ls())
library(Blolog)
library(statnet)
library(lolog)
library(coda)
library(doParallel)
library(ggplot2)
require(bootlog)
setwd("C:/Users/Duncan/Documents/Academics/UCLA_Academics/Networks/LOLOG_Cateloging/1_16_KapfererTailors")
load("processed_data.RData")
model <- lolog(net_1 ~ edges + triangles + star(c(2,3)))
getwd()
setwd("..")
setwd("..")
setwd("LOLOG_Bayesian/writeup/data")
load("tests_kapferer.RData")
test_1$sample
length(test_1$sample)
length(bootstraps)
bootstraps$results
bootstraps$fits
length(bootstraps$fits)
object.size(bootstraps$nets)
#Make the bootstraps networks null to save storage space:
bootstraps$nets <- NULL
object.size(bootstraps)
#======= Save for later =======#
#Save the sample for later
setwd("C:/Users/Duncan/Documents/Academics/UCLA_Academics/Networks/LOLOG_bayesian/working_scripts/kap_tailors")
save(file = "tests_precise.RData",list = c("test_1","test_2","test_3","test_4","sample","bootstraps","model_summary","gof_esp","gof_deg"))
getwd()
setwd("..")
setwd("..")
setwd("..")
list.files()
setwd("LOLOG_Bootstrapped_SEs")
getwd()
setwd("bootlog")
tmp <- devtools::build()
install.packages(tmp,source = T, repo = NULL)
#Fits done under parallisation in estimates_test
#estimates_test returns the LOLOG fits.
bootlog <- function(lolog,
seed = 1,
fits = 10,
cores = 2,
MoreArgs = NULL,
keep_nets = F){
#MoreArgs are additional arguments needed for network fitting e.g. edge covariate matrices
#load in MoreArgs
if(!is.null(MoreArgs)){
for(i in 1:length(MoreArgs)){
assign(names(MoreArgs)[i],MoreArgs[[i]])
}
}
#generate the network
net <- simulate(lolog,nsim = 1,seed= seed)
net <- lolog::as.network(net[[1]])
#make sure network is what we want
formula <- as.character(lolog$formula)
formula[2] <- "sim_net"
formula <- as.formula(paste(formula[2],formula[1],formula[3]))
# #Check that we can fit a lolog to this network:
# if(is.null(tryCatch({lolog(formula)},
#                     error = function(e){print("Unable to fit the LOLOG to the simulated network")
#                       return(NULL)}))){return(NULL)}
#remove original net to stop confusion
rm(net)
fit <- function(net,formula){
sim_net <- lolog::as.network(simulate(lolog,nsim = fits,seed = seed))
tmp <- tryCatch({lolog(formula,verbose = 0)},
error = function(e){return(NA)},
warning = function(w){if(w$message == "In lolog(formula) : Singular statistic covariance matrix. Using diagnoal."){return(NA)}}
)
if(length(tmp)==0){return(NA)}
if(is.na(tmp)){
return(tmp)
}else{
if(keep_nets){return(list(fit = tmp$theta,net = sim_net))}
else{return(rm(sim_net),
list(fit = tmp$theta)}
}
}
print(paste("The parallelisation started at ", Sys.time(),sep = ""))
#if the fits are more that 1000 split up into batches of 1000
cl <- parallel::makeCluster(cores)
registerDoParallel(cl)
fits <- foreach(i = (1:length(sims)), .inorder = FALSE, .packages = "lolog",.errorhandling = "pass") %dopar% {fit(sims[[i]],formula)}
parallel::stopCluster(cl)
print(paste("The parallelisation ended at ", Sys.time(),sep = ""))
if(keep_nets){
return(list(fits = lapply(fits,function(x){x$fit}),nets = lapply(fits,function(x){x$net})))
}else{
return(list(fits = lapply(fits,function(x){x$fit})))
}
}
#Fits done under parallisation in estimates_test
#estimates_test returns the LOLOG fits.
bootlog <- function(lolog,
seed = 1,
fits = 10,
cores = 2,
MoreArgs = NULL,
keep_nets = F){
#MoreArgs are additional arguments needed for network fitting e.g. edge covariate matrices
#load in MoreArgs
if(!is.null(MoreArgs)){
for(i in 1:length(MoreArgs)){
assign(names(MoreArgs)[i],MoreArgs[[i]])
}
}
#generate the network
net <- simulate(lolog,nsim = 1,seed= seed)
net <- lolog::as.network(net[[1]])
#make sure network is what we want
formula <- as.character(lolog$formula)
formula[2] <- "sim_net"
formula <- as.formula(paste(formula[2],formula[1],formula[3]))
# #Check that we can fit a lolog to this network:
# if(is.null(tryCatch({lolog(formula)},
#                     error = function(e){print("Unable to fit the LOLOG to the simulated network")
#                       return(NULL)}))){return(NULL)}
#remove original net to stop confusion
rm(net)
fit <- function(net,formula){
sim_net <- lolog::as.network(simulate(lolog,nsim = fits,seed = seed))
tmp <- tryCatch({lolog(formula,verbose = 0)},
error = function(e){return(NA)},
warning = function(w){if(w$message == "In lolog(formula) : Singular statistic covariance matrix. Using diagnoal."){return(NA)}}
)
if(length(tmp)==0){return(NA)}
if(is.na(tmp)){
return(tmp)
}else{
if(keep_nets){return(list(fit = tmp$theta,net = sim_net))}
else{return(rm(sim_net),
list(fit = tmp$theta)}
}
}
print(paste("The parallelisation started at ", Sys.time(),sep = ""))
#if the fits are more that 1000 split up into batches of 1000
cl <- parallel::makeCluster(cores)
registerDoParallel(cl)
fits <- foreach(i = (1:length(sims)), .inorder = FALSE, .packages = "lolog",.errorhandling = "pass") %dopar% {fit(sims[[i]],formula)}
parallel::stopCluster(cl)
print(paste("The parallelisation ended at ", Sys.time(),sep = ""))
if(keep_nets){
return(list(fits = lapply(fits,function(x){x$fit}),nets = lapply(fits,function(x){x$net})))
}else{
return(list(fits = lapply(fits,function(x){x$fit})))
}
}
fit <- function(net,formula){
sim_net <- lolog::as.network(simulate(lolog,nsim = fits,seed = seed))
tmp <- tryCatch({lolog(formula,verbose = 0)},
error = function(e){return(NA)},
warning = function(w){if(w$message == "In lolog(formula) : Singular statistic covariance matrix. Using diagnoal."){return(NA)}}
)
if(length(tmp)==0){return(NA)}
if(is.na(tmp)){
return(tmp)
}else{
if(keep_nets){return(list(fit = tmp$theta,net = sim_net))}
else{return(rm(sim_net),
list(fit = tmp$theta)}
}
}
fit <- function(net,formula){
sim_net <- lolog::as.network(simulate(lolog,nsim = fits,seed = seed))
tmp <- tryCatch({lolog(formula,verbose = 0)},
error = function(e){return(NA)},
warning = function(w){if(w$message == "In lolog(formula) : Singular statistic covariance matrix. Using diagnoal."){return(NA)}}
)
if(length(tmp)==0){return(NA)}
if(is.na(tmp)){
return(tmp)
}else{
if(keep_nets){return(list(fit = tmp$theta,net = sim_net))
}else{return(rm(sim_net),
list(fit = tmp$theta)}
}
}
fit <- function(net,formula){
sim_net <- lolog::as.network(simulate(lolog,nsim = fits,seed = seed))
tmp <- tryCatch({lolog(formula,verbose = 0)},
error = function(e){return(NA)},
warning = function(w){if(w$message == "In lolog(formula) : Singular statistic covariance matrix. Using diagnoal."){return(NA)}}
)
if(length(tmp)==0){return(NA)}
if(is.na(tmp)){
return(tmp)
}else{
if(keep_nets){return(list(fit = tmp$theta,net = sim_net))
}else{rm(sim_net)
return(list(fit = tmp$theta))}
}
}
tmp <- devtools::build()
install.packages(tmp,source = T, repo = NULL)
library(bootlog)
bootstraps <- bootlog::bootlog_process(model,
seed =123456,
fits = c(2),
cores = NULL,
MoreArgs = NULL)
bootstraps <- bootlog::bootlog_process(model,
seed =123456,
fits = c(2),
cores = 2,
MoreArgs = NULL)
rm(list=ls())
remove.packages("lologOrder")
library(lologOrder)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(cache = TRUE)
library(captioner)
library(statnet)
library(lolog)
library(combinat)
library(sna)
library(gridExtra)
library(kableExtra)
library(coda)
library(ggplot2)
library(reshape2)
library(ggduncan)
library(dplyr)
library(Blolog)
table_nums <- captioner::captioner(prefix = "Table.")
figure_nums <- captioner:: captioner(prefix = "Fig.")
#Load table in for LOLOG fit
load("tests_kapferer.RData")
load("processed_data_kapferer.RData")
model <- lolog(net_1 ~ edges + triangles + star(c(2,3)))
kable(model_summary,format = "latex",booktabs = "T")%>%
kable_styling(latex_options = c("striped"),position = "center")
tmp <- melt(bootstraps$results[,-5],id.vars = c("type"))
table = data.frame(paramter = unique(tmp$variable), mean = tmp[tmp$type =="mean",]$value, se = tmp[tmp$type =="sd",]$value )
names(table) <- c("Parameter","Bootstrap Mean","Bootstrap SE")
kable(table[c(1,3,4,2),],format = "latex",booktabs = "T")%>%
kable_styling(latex_options = c("striped"),position = "center")
par(mfrow = c(2,2))
Blolog::plot_trace(test_1,8)
table <- plot_gelman(test_1,8,names = names(model$theta))
kable(table,format = "latex",booktabs = "T")%>%
kable_styling(latex_options = c("striped"),position = "center")
tmp <- plot_acf(test_1,8,1)
table <- data.frame(Method = c("Random Walk","HMC","Pseudo RMHMC","Bootstrap RMHMC"),
'Approx Burnin' = c(5000,NA,NA,300),
'Approx Burnin Time (Seconds)' =c(400,NA,NA,40))
kable(table,format = "latex",booktabs = "T")%>%
kable_styling(latex_options = c("striped"),position = "center")
tmp <- do.call(rbind,sample)
tmp <- as.data.frame(tmp)
par(mfrow = c(2,2))
for(i in 1:length(model$theta)){
hist(tmp[,i],main  = paste( names(model$theta)[i], " distribution",sep=""))
}
tmp <- as.data.frame(tmp)
names(tmp) <- c("edges","triangles","star.2","star.3")
plot <- ggplot(tmp,aes(x=star.2,y=edges,colour = triangles))+
geom_point(size = 3,alpha = 0.5)+
scale_colour_gradient(low= "yellow",high = "red")
print(plot)
mean_posterior <- apply(tmp,2,mean)
se_posterior <- apply(tmp,2,sd)
p_vals <- apply(tmp,2,function(x){
(mean(x)>0)*(mean(x<=0)) +
(mean(x)<=0)*mean((x>0))
})
table <- cbind(mean_posterior,se_posterior,p_vals)
table <- as.data.frame(table)
table <- round(table,4)
rownames(table) <- c()
table <- cbind(names(tmp),table)
table <- as.data.frame(table)
names(table) = c("Statistic","Mean","SE","P-value")
kable(table,format = "latex",booktabs = "T")%>%
kable_styling(latex_options = c("striped"),position = "center")
